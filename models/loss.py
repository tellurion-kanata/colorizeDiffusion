import torch
import torch.nn as nn

from models.mapper import calculate_scale


def sine_loss(fv, ov, text_features, text_norm):
    """
        Compute the loss along the sine direction.
        fv: fake visual features generated by mapper network
        ov: original visual features
    """
    fv, ov = map(lambda t: t/t.norm(dim=2, keepdims=True), (fv, ov))
    text_features = text_features / text_features.norm(dim=1, keepdim=True)
    f_proj, o_proj = map(lambda t: (t @ text_features.t()) ** 2. / text_norm, (fv, ov))
    fv, ov = map(lambda t: (t ** 2).sum(dim=2), (fv, ov))

    sin_fv = fv - f_proj
    sin_ov = ov - o_proj
    return sin_ov - sin_fv


class MappingLoss(nn.Module):
    def __init__(self, device="cuda"):
        super().__init__()
        self.device = device

    def forward(self, x, sketch, fake_crossattn, real_crossattn, origin_crossattn, text_features,
                real_scale, logit_scale_exp, diffusion_model, split="train"):
        t = torch.randint(0, diffusion_model.num_timesteps, (x.shape[0],), device=self.device).long()
        noise = torch.randn_like(x)
        x_noisy = diffusion_model.q_sample(x_start=x, t=t, noise=noise)

        fake = diffusion_model.apply_model(x_noisy, t, {"c_concat": sketch, "c_crossattn": fake_crossattn})
        real = diffusion_model.apply_model(x_noisy, t, {"c_concat": sketch, "c_crossattn": real_crossattn})
        nll_loss = (real - fake).sum() / x.shape[0]

        text_norm = (text_features ** 2).sum(dim=1).unsqueeze(0)
        cos_loss = ((real_scale - calculate_scale(fake_crossattn, text_features, logit_scale_exp).mean(dim=1, keepdims=True)) * text_norm) ** 2.
        sin_loss = sine_loss(fake_crossattn, origin_crossattn, text_features, text_norm)
        tri_loss = (cos_loss + sin_loss).sum() / (fake_crossattn.shape[0] * fake_crossattn.shape[1])

        loss = nll_loss + tri_loss
        log = {"{}/total_loss".format(split): loss.clone().detach().mean(),
               "{}/nll_loss".format(split): nll_loss.detach().mean(),
               "{}/tri_loss".format(split): tri_loss.detach().mean(),
               "{}/sin_loss".format(split): sin_loss.detach().mean(),
               "{}/cos_loss".format(split): cos_loss.detach().mean(),}
        return loss, log